} else {
z <-z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin ==1) {
z <-z +1
} else {
z <-z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin ==1) {
z <-z +1
} else {
z <-z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin ==1) {
z <-z +1
} else {
z <-z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin ==1) {
z <-z +1
} else {
z <-z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin ==1) {
z <-z +1
} else {
z <-z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin ==1) {
z <-z +1
} else {
z <-z -1
}
}
exit
exit
exit
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
source('~/.active-rstudio-document')
# }
z <- 5
while(z >= 3 && z <=10) {
print(z)
coin <- rbinom(1,0,0.5)
if(coin == 1) {
z <- z +1
} else {
z <- z -1
}
}
exit
args(rbinom)
source('~/R/while-example.r')
x
clear
exit
>
args(binom)
args(rbinom)
args(seq_len)
args(paste)
args(cat)
search()
setwd("~/R")
source('~/.active-rstudio-document')
makeVector(2)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
makeVector(2)
setwd("C:/Users/araike/ProgrammingAssignment2")
source('~/.active-rstudio-document')
x = rbind(c(1, -1/4, c(-1/4,1))
m = makeCacheMatrix(x)
source('~/.active-rstudio-document')
## Assignment: Caching the Inverse of a Matrix
## Matrix inversion is usually a costly computation
## The objective assignment is to cache the inverse
## of a matrix rather than computing it repeatedly
## These two functions cache the inverse of a matrix.
## makeCacheMatrix function
## This function creates a special "matrix" object
## that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
## invFunc stores the cached inverse matrix
## set to NULL
invFunc <- NULL
## sets the value of the matrix
set <- function(y) {
x <<- y
invFunc <<- NULL
}
## gets the value of the matrix
get <- function() x
## sets the value of the inverse
setinverse <- function(solve) invFunc <<- solve
## gets the value of the inverse
getinverse <- function() invFunc
## generate the matrix list
list(set = set, get = get,setinverse = setinverse,getinverse = getinverse)
}
## cacheSolve function returns the inverse of the matrix.
##
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
invFunc <- x$getinverse()
if(!is.null(invFunc)) {
message("getting cached data.")
return(invFunc)
}
data <- x$get()
invFunc <- solve(data)
x$setinverse(invFunc)
invFunc
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
m$get()
source('~/.active-rstudio-document')
22
## Assignment: Caching the Inverse of a Matrix
## Matrix inversion is usually a costly computation
## The objective assignment is to cache the inverse
## of a matrix rather than computing it repeatedly
## These two functions cache the inverse of a matrix.
## makeCacheMatrix function
## This function creates a special "matrix" object
## that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
## invFunc stores the cached inverse matrix
## set to NULL
invFunc <- NULL
## sets the value of the matrix
set <- function(y) {
x <<- y
invFunc <<- NULL
}
## gets the value of the matrix
get <- function() x
## sets the value of the inverse
setinverse <- function(solve) invFunc <<- solve
## gets the value of the inverse
getinverse <- function() invFunc
## generate the matrix list
list(set = set, get = get,setinverse = setinverse,getinverse = getinverse)
}
## cacheSolve function returns the inverse of the matrix.
##
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
invFunc <- x$getinverse()
if(!is.null(invFunc)) {
message("getting cached data.")
return(invFunc)
}
data <- x$get()
invFunc <- solve(data)
x$setinverse(invFunc)
invFunc
}
x = rbind(c(2, -1), c(-1, 2))
m = makeCacheMatrix(x)
m$get()
